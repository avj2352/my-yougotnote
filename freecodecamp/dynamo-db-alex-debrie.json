{
    "id": "playlist-e5922860-7e49-49d9-bf77-2e12e9d9cff6",
    "title": "DynamoDB Modelling - Alex DebRie",
    "createdBy": "",
    "bookmarks": [{
        "id": "bookmark-bae7d0e5-2e83-47b5-9ac7-532679c5b143",
        "description": "<p>Introduction to Dynamo DB</p>",
        "start": 215,
        "position": 1,
        "video": {
            "id": "video-8ce5bf85-ef78-4878-94d2-143afb09d6d6",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 214.56559510288284,
            "total": 4275.981
        }
    }, {
        "id": "bookmark-85c83e6b-bac6-4261-a3d4-a7614ea0b651",
        "description": "<p>Why Dynamo DB ?<br><br>People switching from RDBMS<br>- Connection model<br>- Hyper ephermal compute with Lambda<br>- VPC cold-start<br>- Connection limits to RDBMS Databases<br><br>Dynamo connection only on Network Layer (HTTP connection model)<br>- No connection limits</p>",
        "start": 247,
        "position": 2,
        "video": {
            "id": "video-e026b66a-1508-4e94-82b1-0f8a483a5c4d",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 247.49071200907179,
            "total": 4275.981
        },
        "pin": "red"
    }, {
        "id": "bookmark-9944cb13-00ab-4318-9a43-3efd1f4ac149",
        "description": "<blockquote><p>\"We were doing Dynamo DB wrong!\"</p></blockquote><p>&nbsp;</p><p>+ How to use Access Patterns<br>+ How to make data fit into Dynamo DB</p><p>+ NoSQL getting better since 2016</p>",
        "start": 321,
        "position": 3,
        "video": {
            "id": "video-41c3ec83-81b4-4c98-8743-b1c4dc05d249",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 321.04203568236045,
            "total": 4275.981
        },
        "pin": "green"
    }, {
        "id": "bookmark-168df5f5-4c3e-4750-ab7a-4cb3afa36241",
        "description": "<p>Background on Dynamo DB<br><br>+ Why choose Dynamo DB ?<br>+ Basics concepts of Dynamo DB<br>+ Single Table concepts</p>",
        "start": 407,
        "position": 4,
        "video": {
            "id": "video-607a3017-7efc-4b05-96f5-85d40285a386",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 406.5813659657573,
            "total": 4275.981
        }
    }, {
        "id": "bookmark-a1c69fc7-3013-437c-b0ce-89b3ce00cd57",
        "description": "<p>Compare Relational Databases to Dynamo DB<br><br>+ RDBMS - MySQL gets slower &amp; slower as data size increases (1GB - 1TB)<br>+ Dynamo DB - Consistent fast even if data reaches 1TB</p>",
        "start": 450,
        "position": 5,
        "video": {
            "id": "video-86f67010-3b17-494f-8861-acb74626554f",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 450.29152004151877,
            "total": 4275.981
        }
    }, {
        "id": "bookmark-43e5bfe9-2135-4c48-bb05-516f7fb578fc",
        "description": "<p>Data model with Access Patterns&nbsp;-<br><br>+ Primary Key - made up of PartitionKey &amp; SortKey<br>+ Primary Key needs to be unique<br>+ Primary Key is used to access the data<br>+ Attributes are read only (meaning you cannot query them, they come along for the ride when you access records using Primary key)<br><br>Best practices -<br><br>+ Keep your Partition key as PK &amp; your Sort Key as SK</p>",
        "start": 598,
        "position": 6,
        "video": {
            "id": "video-652ed2d9-1258-4042-a3e7-a850b7ed8365",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 598.3006724135636,
            "total": 4275.981
        }
    }, {
        "id": "bookmark-bd220411-7656-42a5-959a-024830d486e5",
        "description": "<p>We will create a Dynamo DB for an Instagram Clone<br><br>Entities<br>+ Users<br>+ Photos<br>+ Likes<br>+ Comments<br>+ Likes on comments, replies on comments</p>",
        "start": 694,
        "position": 7,
        "video": {
            "id": "video-f97f0a70-5283-4ea6-bce4-bdf9ed819de1",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 694.0029897105675,
            "total": 4276
        }
    }, {
        "id": "bookmark-52b6fa28-b6e1-46c9-8527-59c790a629b1",
        "description": "<p>Single Table with PK + SK =&gt; Type</p>",
        "start": 711,
        "position": 8,
        "video": {
            "id": "video-446fa7e1-185e-4555-a84b-811dcdb21ab7",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 711.3921142561362,
            "total": 4276
        }
    }, {
        "id": "bookmark-99852b76-f034-4ac7-b35a-df84094a12f1",
        "description": "<p>\"Why single Table ?\"<br><br>+ No Joins in Dynamo DB<br>+ Different entities can be accessed in single request<br>+ Put them in same table in same item collection<br>+ On Demand Mode - easier to maintain, provision capacity on one table than different tables<br>+ Forces you to think \"Dynamo DB\" - Makes you think Access Patterns beforehand</p>",
        "start": 737,
        "position": 9,
        "video": {
            "id": "video-84a313b1-9d19-4cb2-9545-b5abe6946f75",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 736.5370272908996,
            "total": 4275.981
        },
        "pin": "red"
    }, {
        "id": "bookmark-fc6dd2f4-3476-4f70-a203-be8c3e1a459f",
        "description": "<p><strong>Modelling a Single Table in Dynamo DB</strong><br><br>+ <a href=\"https://github.com/alexdebrie/dynamodb-instagram\">[github repo](alexdebrie/dynamodb-instagram)</a><br>+ Terms, Concepts, Constraints<br>+ Plan your Access Patterns first<br>+ Consider how you will use API requests to access your Entities<br>+ Entity Chart (think what is PK, SK patterns)</p>",
        "start": 949,
        "position": 10,
        "video": {
            "id": "video-fa5220f7-160a-443c-a926-cbd898fc8529",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 949.2982166149969,
            "total": 4276
        }
    }, {
        "id": "bookmark-549349de-dea7-42b1-bb9a-929660c90732",
        "description": "<p>\"Can you explain what is difference between Partition Key &amp; Sort Key\"<br><br>There are 2 types of Primary Keys<br>+ Simple Primary Keys - has just Partition Key (key value type, gives you single item at a time)<br>+ Composite Primary Keys - is made up of Partition Key &amp; Sort Key (for complex access and for more scalable applications)<br>+ GSI You can create secondary indexes - gives you another Primary Key</p>",
        "start": 1261,
        "position": 11,
        "video": {
            "id": "video-b0b5784e-4ee3-47b8-9ba5-0ff2b24a2a5e",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 1260.5162400043928,
            "total": 4276
        },
        "pin": "red"
    }, {
        "id": "bookmark-058c0778-7cf9-40de-893f-30bd4ce27c07",
        "description": "<p>Another important difference between RDBMS and NoSQL Dynamo DBs<br><br>+ Relational Databases - You normalise your data first then think about your Access Patterns<br>+ Dynamo DB - You think about your access patterns first, then design your entities within a single table</p>",
        "start": 1533,
        "position": 12,
        "video": {
            "id": "video-231e8061-220a-4771-883d-9d9003a4e7cf",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 1532.8443409053646,
            "total": 4275.981
        },
        "pin": "purple"
    }, {
        "id": "bookmark-52779265-7c14-4989-a432-795fcb4ea980",
        "description": "<p>\"How do you keep up with applications that keep growing, changing, migrating &amp; plan your Access Patterns\"<br><br>Depends on the Type of Migrations -&nbsp;<br>+ Adding new attributes to existing items (simple - null, because Dynamo DB is schema-less)<br>+ When adding new Entity<br>+ Existing Data accessed in new ways (gets tricky..., update manually then create Secondary indexes - SCAN, IDENTIFY &amp; UPDATE)</p>",
        "start": 1564,
        "position": 13,
        "video": {
            "id": "video-890e4e03-6540-454c-8d6b-f7674df84924",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 1564.284684472265,
            "total": 4275.981
        },
        "pin": "red"
    }, {
        "id": "bookmark-74ad1e13-d29e-4376-ba95-204eda88b614",
        "description": "<p>Infrastructure as Code, creating a Dynamo DB Table with Primary Keys<br><br>Configure a Composite Primary Key as follows -<br>&nbsp;</p><pre><code class=\"language-plaintext\">KeySchema\n- AttributeName: \"PK\"\n  KeyType: \"HASH\"\n- AttributeName: \"SK\"\n  KeyType: \"RANGE\"</code></pre><p>&nbsp;</p><p>In Serverless, its HASH &amp; RANGE where as in Dynamo DB is \"PARTITION\" and \"SORT\"</p>",
        "start": 1938,
        "position": 14,
        "video": {
            "id": "video-8781926f-a4db-4dca-b816-0aca96421e74",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 1937.6093391349993,
            "total": 4276
        },
        "pin": "red"
    }, {
        "id": "bookmark-6b5a7de6-b270-45db-aee8-c811a3942f2a",
        "description": "<pre><code class=\"language-plaintext\">BillingMode: \"PAY_PER_REQUEST\"</code></pre><p><br><strong>Different type of Billing Modes in Dynamo DB</strong><br><br>+ Traditional Billing Mode - \"PROVISION_BY_CAPACITY\" - This is how many Read Units and Write Units I want, provisioned for you ahead of time<br>+ \"PAY_PER_REQUEST\" - You dont need to provision anything upfront in advance, They charge accordingly as your application scales.<br>+ \"PAY_PER_REQUEST\" - is more than \"PROVISION_BY_CAPACITY\" - Better than PROVISION, use it until your monthly bill scales up!</p>",
        "start": 2051,
        "position": 15,
        "video": {
            "id": "video-7cfbe495-d9e2-4137-a792-c9324090068f",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 2050.65248622011,
            "total": 4276
        },
        "pin": "red"
    }, {
        "id": "bookmark-b0cf8767-eb78-405a-9a90-485b280e5c07",
        "description": "<p>Typescript - Abstract class to store a Record (Item) into a Dynamo DB Document&nbsp;<br><br><i><strong>ðŸ¤” Reason for this:&nbsp;</strong></i><br>Creating this Abstract class and then making all your Business Logic Entities inherit from this will separate your business logic entities from \"indexing\" entities</p><p>&nbsp;</p><pre><code class=\"language-javascript\">/**\n* src/data/base.ts\n* Abstract class to store a record / item into Dynamo DB\n* Defines a few important fields that every entity that sub-classes this class\n**/\nimport { DynamoDB } from \"aws-sdk\"\n\nexport abstract class Item {\n    abstract get pk(): string\n    abstract get sk(): string\n\n    public keys(): DynamoDB.Key {\n        return {\n            PK: { S: this.pk },\n            SK: { S: this.sk }\n        }\n    }\n    \n    // implement this method to store items to dynamo db\n    abstract toItem(): Record&lt;string, unknown&gt;\n}</code></pre>",
        "start": 2315,
        "position": 16,
        "video": {
            "id": "video-7809966f-4557-49b9-a4e3-7c0e6c30e875",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 2315.1823045708334,
            "total": 4276
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-3a126adf-3ea1-47f0-adb6-8b8139335af8",
        "description": "<p>Example of how an Entity - \"User\" inherits the base class and gets those indexing keys out-of-the-box</p><p>&nbsp;</p><pre><code class=\"language-javascript\">/**\n* User entity inherit Base.ts\n**/\n\nimport { DynamoDB } from \"aws-sdk\"\nimport { Item } from \"./base\"\nimport { getClient } from \"./client\"\n\nexport class User extends Item {\n    username: string\n    name: string\n    followerCount: number\n    followingCount: number\n\n    constructor(username: string, name?: string, followerCount?: number, followingCount?: number) {\n        super()\n        this.username = username\n        this.name = name || \"\"\n        this.followerCount = followerCount || 0\n        this.followingCount = followingCount || 0\n    }\n\n    // helper method to retrieve record from dynamo db and return as an instance\n    static fromItem(item?: DynamoDB.AttributeMap): User {\n        if (!item) throw new Error(\"No item!\")\n        return new User(item.username.S, item.name.S, Number(item.followerCount.N), Number(item.followingCount.N))\n    }\n\n    // here we define which of our indexing fields from User entity will be indexed\n    get pk(): string {\n        return `USER#${this.username}`\n    }\n\n    // here we define which of our indexing fields from User entity will be grouped\n    get sk(): string {\n        return `USER#${this.username}`\n    }\n\n    // implement abstract method to store to dynamo db\n    toItem(): Record&lt;string, unknown&gt; {\n        return {\n            ...this.keys(),\n            username: { S: this.username },\n            name: { S: this.name },\n            followerCount: { N: this.followerCount.toString() },\n            followingCount: { N: this.followingCount.toString() }\n        }\n    }\n}\n\nexport const createUser = async (user: User): Promise&lt;User&gt; =&gt; {\n    const client = getClient()\n\n    try {\n        await client\n            .putItem({\n                TableName: process.env.TABLE_NAME,\n                Item: user.toItem(),\n                ConditionExpression: \"attribute_not_exists(PK)\" // create guards to ensure uniqueness\n            })\n            .promise()\n        return user\n    } catch (error) {\n        console.log(error)\n        throw error\n    }\n}\n\nexport const getUser = async (username: string): Promise&lt;User&gt; =&gt; {\n    const client = getClient()\n    const user = new User(username, \"\")\n\n    try {\n        const resp = await client\n            .getItem({\n                TableName: process.env.TABLE_NAME,\n                Key: user.keys()\n            })\n            .promise()\n        return User.fromItem(resp.Item)\n    } catch (error) {\n        console.log(error)\n        throw error\n    }\n}</code></pre>",
        "start": 2519,
        "position": 17,
        "video": {
            "id": "video-f8ccdc84-3b3e-4bc0-8c78-1ee319c2a9b8",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 2518.522982684006,
            "total": 4275.981
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-7704d222-9fbc-43a9-906a-c88fade3b567",
        "description": "<p>What is a <strong>Condition Expression</strong> ?&nbsp;</p><p>&nbsp;</p><p>+ A Condition Expression is like a guard statement. It evaluates to a true or false<br>+ Whenever you do a \"<strong>write</strong>\" operation to dynamo or you <strong>update the state</strong> of a record in dynamo db<br>+ The condition expression is evaluated before the <strong>write</strong>. false will cancel out the <strong>write</strong><br>+ Write operations - put item, update item, delete item<br>+ it's atomic, no race conditions</p>",
        "start": 2620,
        "position": 18,
        "video": {
            "id": "video-fb18e068-f47f-4193-ae9e-9b28c30a9136",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 2620.142104755618,
            "total": 4275.981
        },
        "pin": "red"
    }, {
        "id": "bookmark-5eea73f7-5a28-4079-a37c-bb4d5d8840c0",
        "description": "<p>Helper function (can also be a helper class) to fetch Dynamo DB Document client. Other reasons -</p><p>&nbsp;</p><p>+ When creating dynamo db client, certain parameters - <strong>connectTimeout</strong> &amp; request <strong>timeout</strong><br>+ Cutting of connectTimeout - 1000<br>+ Cutting of request timeout - 1000<br>+ Default timeout is 30 seconds - 30000<br>+ Also caches the client, creates a singleton class. every class uses the same reference</p><p>&nbsp;</p><pre><code class=\"language-javascript\">/**\n* Helper method / class to fetch Dynamo DB Document client\n**/\nimport { DynamoDB } from \"aws-sdk\";\n\nlet client = null\n\nexport const getClient = (): DynamoDB =&gt; {\n    if (client) return client\n    client = new DynamoDB({\n        httpOptions: {\n            connectTimeout: 1000,\n            timeout: 1000\n        }\n    })\n    return client\n}</code></pre>",
        "start": 2757,
        "position": 19,
        "video": {
            "id": "video-baf77159-0f8f-4de0-8479-23cafff6136a",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 2756.5853248444296,
            "total": 4275.981
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-4515199b-a385-4019-93f0-63193f86223e",
        "description": "<p>How do you test this / locally or mock the service. Recommended or not ?<br><br>+ Different people like different things<br>+ API Gateway, Lambda, Dynamo DB - these resources CAN be tested locally easily<br>+ Other parts - SQS, EventBridge, Kinesis - a lot of this cannot be tested locally, recommended to test in cloud</p>",
        "start": 2905,
        "position": 20,
        "video": {
            "id": "video-5de6a9c6-1a90-48e4-8c1c-12b6f680c54b",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 2905.1452529543512,
            "total": 4275.981
        },
        "pin": "purple"
    }, {
        "id": "bookmark-1f70f69e-3f4b-4029-9da0-22eb75f522b3",
        "description": "<p>Important Library to use for Constructing APIs&nbsp;</p><p>&nbsp;</p><pre><code class=\"language-plaintext\">npm i ulid</code></pre><p>&nbsp;</p><p>+ They support every major language<br>+ Uniqueness of <strong>uuid </strong>but prefixed with a <strong>timestamp</strong><br>+ You will get sorting as well as uniqueness<br>+ Another alternative - <strong>ksid</strong></p>",
        "start": 3130,
        "position": 21,
        "video": {
            "id": "video-062f766b-c2c0-42cd-9d08-576bb6ea0108",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 3130.348766658739,
            "total": 4275.981
        },
        "pin": "green"
    }, {
        "id": "bookmark-f83db96f-299c-490c-afed-bbe6358637ac",
        "description": "<p>Introduction to <strong>Transactions</strong> in Dynamo DB<br><br>+ New feature as of AWS:Reinvent 2018<br>+ Can perform multiple write operation at once in a single transaction operation / single request<br>+ If one of the operation fails, all of them will fail.&nbsp;<br>+ This will make them more atomic<br>+ Transactions can also target multiple tables</p><p>&nbsp;</p><pre><code class=\"language-javascript\">/**\n* src/data/like.ts\n* The following method will add a record as well as update the like counter\n**/\nexport const likePhoto = async (photo: Photo, likingUsername: string): Promise&lt;Like&gt; =&gt; {\n    const client = getClient()\n    const like = new Like(likingUsername, photo.photoId)\n\n    try {\n        await executeTransactWrite({\n            client,\n            params: {\n                TransactItems: [\n                    {\n                        Put: {\n                            TableName: process.env.TABLE_NAME,\n                            Item: like.toItem(),\n                            ConditionExpression: \"attribute_not_exists(PK)\"\n                        }\n                    },\n                    {\n                        Update: {\n                            TableName: process.env.TABLE_NAME,\n                            Key: photo.keys(),\n                            ConditionExpression: \"attribute_exists(PK)\",\n                            UpdateExpression: \"SET #likesCount = #likesCount + :inc\",\n                            ExpressionAttributeNames: {\n                                \"#likesCount\": \"likesCount\"\n                            },\n                            ExpressionAttributeValues: {\n                                \":inc\": { N: \"1\" }\n                            }\n                        }\n                    }\n                ]\n            }\n        })\n        return like\n    } catch (error) {\n        console.log(error)\n        throw error\n    }\n}</code></pre>",
        "start": 3422,
        "position": 22,
        "video": {
            "id": "video-04d13112-719e-4710-be9d-f684f4981fc3",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 3421.6294742542304,
            "total": 4275.981
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-086ddd00-8f34-42d8-8258-3f324d2d1706",
        "description": "<p>Using <strong>Query</strong> operation<br><br>+ Can query a list of records<br>+ Can sort by time, get latest by time<br>+ Can do a little \"search\" (sort of)<br>+ If you only know \"part\" of the primary key, you can use query in that case</p><p>&nbsp;</p><pre><code class=\"language-javascript\">/**\n* Queries a secondary index\n**/\nexport const listLikesForPhoto = async (photoId: string): Promise&lt;Like[]&gt; =&gt; {\n    const client = getClient()\n    const like = new Like(\"\", photoId)\n\n    try {\n        const resp = await client\n            .query({\n                TableName: process.env.TABLE_NAME,\n                IndexName: \"GSI1\",\n                KeyConditionExpression: \"GSI1PK = :gsi1pk\",\n                ExpressionAttributeValues: {\n                    \":gsi1pk\": { S: like.gsi1pk }\n                },\n                ScanIndexForward: false\n            })\n            .promise()\n        return resp.Items.map((item) =&gt; Like.fromItem(item))\n    } catch (error) {\n        console.log(error)\n        throw error\n    }\n}</code></pre>",
        "start": 3697,
        "position": 23,
        "video": {
            "id": "video-6626de6f-91d7-4b72-a938-e6e415092135",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 3697.496279405578,
            "total": 4275.981
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-8260042d-926f-4211-9e76-bcdfabe6e04a",
        "description": "<p>One more important Operation - <strong>batchGetItem&nbsp;</strong></p><p>&nbsp;</p><p>+ This operation will replace multiple reads using a loop to a Database&nbsp;</p><p>&nbsp;</p><pre><code class=\"language-javascript\">// instead of reading multiple times using a loop, use - batchGetItem\ntry {\n        const resp = await client.batchGetItem({\n            RequestItems: {\n                [process.env.TABLE_NAME]: {\n                    Keys: keys\n                }\n            }\n        }).promise()\n        return resp.Responses[process.env.TABLE_NAME].map((item) =&gt; User.fromItem(item))\n    } catch (error) {\n        console.log(error)\n        throw error\n    } </code></pre>",
        "start": 3832,
        "position": 24,
        "video": {
            "id": "video-fd23103a-3bb0-461e-90c7-f61d56f08e0b",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 3831.5910566184916,
            "total": 4275.981
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-87e6293a-a2af-4a53-962e-e42c05c74891",
        "description": "<p><strong>OUTRO</strong><br><br>+ Github repo of the project: <a href=\"https://github.com/alexdebrie/dynamodb-instagram\">https://github.com/alexdebrie/dynamodb-instagram</a><br>+ Look into the Dynamo Documentation<br>+ Follow Alex DebRie on twitter: <a href=\"https://twitter.com/alexbdebrie\">https://twitter.com/alexbdebrie</a><br>+ The DynamoDB book: <a href=\"https://www.dynamodbbook.com/\">https://www.dynamodbbook.com/</a></p>",
        "start": 4112,
        "position": 25,
        "video": {
            "id": "video-9f432ab0-49c2-4d85-9dfd-d8bf70cfacb3",
            "url": "https://www.youtube.com/watch?v=Q6-qWdsa8a4",
            "seen": 4111.530922276667,
            "total": 4275.981
        },
        "pin": "green"
    }]
}
