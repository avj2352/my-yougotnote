{
    "id": "playlist-63a36c13-ef2a-4664-9f80-e473e6b08df1",
    "title": "Dynamic Programming Basics - Collection",
    "createdBy": "",
    "bookmarks": [{
        "id": "bookmark-21339cfd-0cad-4a31-bdbd-168b750cd78c",
        "description": "<p>Hey Programmers, I am Alvin</p><p>&nbsp;</p><p>Welcome to - <strong>Dynamic Programming Course</strong></p>",
        "start": 6,
        "position": 1,
        "video": {
            "id": "video-355f99c0-4a3f-4697-9f68-74bd889ad203",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 5.821207,
            "total": 18602
        }
    }, {
        "id": "bookmark-5329c162-967b-4460-9dea-5989aafc9e45",
        "description": "<p><i>Problems we're going to solve in this course -</i><br>&nbsp;</p><p>1. Calculate the 40th number of fibonacci sequence</p><p>2. Count the number of different ways to move through a 6x9 grid</p><p>3. Given a set of coins, how can we make 27 cents in the least number of coins</p><p>4. Given a set of substrings, what're the possible ways to construct the string <strong>\"potentpot\"</strong></p>",
        "start": 49,
        "position": 2,
        "video": {
            "id": "video-e8affe11-dd9b-4db6-a7b2-3a9773d5e14a",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 48.78339704005432,
            "total": 18602
        },
        "pin": "green"
    }, {
        "id": "bookmark-87c3f6d2-33b1-440d-8879-76de4363d436",
        "description": "<p>Visualize algorithms</p>",
        "start": 102,
        "position": 3,
        "video": {
            "id": "video-3ebdb82d-8a2a-43cc-9d28-07bb6ebb7340",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 101.85076303814698,
            "total": 18602
        }
    }, {
        "id": "bookmark-cee30b07-8d9b-49ff-9f41-93268e1f7ce2",
        "description": "<p><i>Dynamic Programming concepts - <strong>solving Overlapping Sub-problems</strong> &nbsp;techniques covered -</i><br><br>Part 1: Memoization<br>Part 2: Tabulation<br><br><i>Pre-requisite required</i><br><br>1. Basics of Recursion<br>2. Basics of Complexity Analysis</p>",
        "start": 166,
        "position": 4,
        "video": {
            "id": "video-b8a8124f-766a-4646-92fc-2543a2793d9e",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 166.10665610681153,
            "total": 18602
        },
        "pin": "green"
    }, {
        "id": "bookmark-d7dbb6d0-c065-41c9-8995-0cf845315ed2",
        "description": "<p>📜 <strong>Challenge #1 - program a fibonacci using memoization</strong><br><br><i>Write a function fib(n) that takes in a number as an argument. The function should return the nth number of the Fibonacci sequence</i><br><br>+ The 1st &amp; 2nd number of the sequence is 1.<br>+ To generate the next number of the sequence, we sum the previous two<br>&nbsp;</p>",
        "start": 206,
        "position": 5,
        "video": {
            "id": "video-3ac0215e-3858-4175-9f09-dcbeb40b6c77",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 205.677969,
            "total": 18602
        },
        "pin": "yellow"
    }, {
        "id": "bookmark-782c2eb7-86c1-4301-977c-5240cd562485",
        "description": "<p>Classic implementation</p><pre><code class=\"language-javascript\">// Classic implementation (w/o memoization)\nconst fib = (n) =&gt; {\n // base-case\n if (n&lt;=2) return 1;\n // recursive case\n return fib(n-1) + fib(n-2);\n};\n\nconsole.log(fib(6)); // 8\nconsole.log(fib(7)); // 13\nconsole.log(fib(8)); // 21\nconsole.log(fib(50)); // takes a looong time</code></pre><p>&nbsp;</p><p><strong>Review: </strong>Problem with this approach - We are re-visiting already visited / computed numbers</p>",
        "start": 275,
        "position": 6,
        "video": {
            "id": "video-a5c31f2e-fd3e-4158-9854-d5d8974441eb",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 275.45966992370603,
            "total": 18602
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-218122a5-67ef-41a4-97a4-d808348f05a3",
        "description": "<p>Students need to work on drawing things....</p>",
        "start": 406,
        "position": 7,
        "video": {
            "id": "video-e55ae7e7-7965-4344-a3a1-a0362d7a9c57",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 405.7348070190735,
            "total": 18602
        }
    }, {
        "id": "bookmark-c1dd9097-4480-44af-a728-b0f7b8c509cc",
        "description": "<p>Drawing a tree to explain optimization approach</p>",
        "start": 457,
        "position": 8,
        "video": {
            "id": "video-86e46e83-fee0-46d4-a26d-bb7170662be8",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 456.75220912016295,
            "total": 18602
        },
        "pin": "red"
    }, {
        "id": "bookmark-6258308c-10da-417f-bf81-50f641666264",
        "description": "<p>The Above solution approach is explained...<br><br>+ For all of these base cases, I know they return 1 to their parent<br>+ and all the parent nodes add up these base cases</p>",
        "start": 615,
        "position": 9,
        "video": {
            "id": "video-138b84b9-e006-40bc-9126-ccc0eb130930",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 615.4869470267029,
            "total": 18602
        }
    }, {
        "id": "bookmark-32c3daf8-3ace-49b9-a815-2137210e5aa3",
        "description": "<p>Time Complexity<br><br>+ Off-hand people mention that a Fibonacci recursive implementation Big-O is - <strong>2^n</strong><br>+ This drawing is asymmetric.<br>+ Students have a real hard time convincing themselves on this <strong>2^n</strong></p>",
        "start": 646,
        "position": 10,
        "video": {
            "id": "video-0beb427f-cc06-425c-befe-99b4fdb20f66",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 646.2404470267029,
            "total": 18601.941
        }
    }, {
        "id": "bookmark-209abced-658e-439d-8b59-db51cbe7cede",
        "description": "<p><strong>Basic refresher of Space Time Complexity for Recursion -</strong><br><br><strong>Example #1</strong><br>&nbsp;</p><pre><code class=\"language-javascript\">const foo = (n) =&gt; {\n if(n&lt;=1) return;\n foo(n-1);\n};</code></pre><p>&nbsp;</p><p>+ Time Complexity - <strong>O(n) - </strong>Takes n time to go through recursion</p><p>+ Space Complexity - <strong>O(n) </strong>- N times the function is called - Stacks function therefore <strong>O(n)</strong></p><p>&nbsp;</p><p><strong>Example #2</strong></p><p>&nbsp;</p><pre><code class=\"language-javascript\">const bar = (n) =&gt; {\n if(n&lt;=1) return;\n foo(n-2);\n};</code></pre><p>&nbsp;</p><p>+ Time Complexity - O(n/2) ~ O(n)<br>+ Space Complexity - O(n/2) ~ O(n)</p>",
        "start": 685,
        "position": 11,
        "video": {
            "id": "video-1146e212-beaf-4e4c-83e3-ff6611fb5f69",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 684.8481930648499,
            "total": 18601.941
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-d86014c4-8f9a-454d-9303-645488c602a9",
        "description": "<p><strong>Example #3</strong></p><p>&nbsp;</p><pre><code class=\"language-javascript\">// produces a symmetric tree\nconst dib = (n) =&gt; {\n if (n&lt;=1) return;\n dib(n-1); // left child\n dib(n-1); // right child\n};</code></pre><p><br>+ Time Complexity - <strong>O(2^n)</strong><br>&nbsp; &nbsp; &nbsp;- First consider one of the paths, that will also be the height of the tree<br>&nbsp; &nbsp; &nbsp;- Height is also called - Levels<br>&nbsp; &nbsp; &nbsp;- The number of nodes doubles every level<br>+ Space Complexity - <strong>O(n)</strong><br>&nbsp; &nbsp; - Students always assume Space = Time when it comes to recursive function<br>&nbsp; &nbsp; - At any given time, the number of stacks is same as that of the height of the tree</p>",
        "start": 853,
        "position": 12,
        "video": {
            "id": "video-8505f7e9-b4e4-4278-805a-576019c3635e",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 853.1214597959137,
            "total": 18601.941
        },
        "pin": "red"
    }, {
        "id": "bookmark-ca47d8b2-00d3-45d9-bd0f-a6c8de9949db",
        "description": "<p><strong>Example #4</strong></p><p>&nbsp;</p><pre><code class=\"language-javascript\">// produces a symmetric tree\nconst lib = (n) =&gt; {\n if (n&lt;=1) return;\n dib(n-2); // left child\n dib(n-2); // right child\n};</code></pre><p><br>+ Time Complexity - <strong>O(2^n/2) ~ O(2^n)</strong><br>&nbsp; &nbsp; &nbsp;- First consider one of the paths, that will also be the height of the tree<br>&nbsp; &nbsp; &nbsp;- Height is also called - Levels<br>&nbsp; &nbsp; &nbsp;- The number of nodes SKIPS two steps every level so the height is halved.<br>+ Space Complexity - <strong>O(n/2) ~ O(n)</strong><br>&nbsp; &nbsp; - Students always assume Space = Time when it comes to recursive function<br>&nbsp; &nbsp; - At any given time, the number of stacks is half as that of the height of the tree</p>",
        "start": 1200,
        "position": 13,
        "video": {
            "id": "video-f5286d4f-8d77-4bc3-8d87-0107539602ef",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 1199.664206885559,
            "total": 18602
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-a425bb55-5a97-447c-b038-e70239523f8f",
        "description": "<p>Where does our Fibonacci fit in these 4 examples ?</p><p>&nbsp;</p><pre><code class=\"language-plaintext\">Time - O(dib) &lt;= O(fib) &lt;= O(lib)</code></pre>",
        "start": 1281,
        "position": 14,
        "video": {
            "id": "video-786219cd-2368-48a2-8b94-13c611d4d912",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 1281.149031049591,
            "total": 18602
        }
    }, {
        "id": "bookmark-139055ac-b2f2-469d-aa0e-d04ece62e6df",
        "description": "<p>O(2^n) is not a good Time Complexity (explained)...<br><br>+ Consider fib(50) ~ 2^50<br>+ if we just bring up the calculator &amp; do a 2 raised to 50 = <strong>1,1,25,899,906,842,624</strong> steps !!&nbsp;<br>+ One quadrillion steps</p>",
        "start": 1356,
        "position": 15,
        "video": {
            "id": "video-4b57cc6a-2bf1-424b-827b-6c30891bae9a",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 1356.2389128550415,
            "total": 18602
        },
        "pin": "red"
    }, {
        "id": "bookmark-8c14283f-cfd8-4322-8bce-44db1958babd",
        "description": "<p><strong>Overlapping Sub-problems explained...</strong></p><p>&nbsp;</p><p>+ A lot of duplicates in my subtree</p><p>+ I know my previous number fibonacci doesn't change</p><p>&nbsp;</p><p><i>Solving these kind of Overlapping Sub-problems is the core of <strong>\"Dynamic Programming\"</strong></i></p><p>&nbsp;</p><p>+ Any instance where we have a larger problem, We decompose it into smaller sub-problems</p><p>+ We also have overlapping sub-problems</p><p>+ Identify which of the sub-problem is &nbsp;a duplicate</p>",
        "start": 1441,
        "position": 16,
        "video": {
            "id": "video-069e5147-48c4-4a8a-8c3c-09f3c0cce75b",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 1440.895907956131,
            "total": 18602
        },
        "pin": "red"
    }, {
        "id": "bookmark-78ea8ed9-3cd0-4fef-95d6-b701b38e3f99",
        "description": "<p><strong>Solution to optimize Class Fibonacci implementation (Javascript)</strong></p><p>&nbsp;</p><p>+ Create a memo (fast access - HashMap / Map / Object in Javascript)</p><p>+ keys to the memo will be the argument to the function</p><p>+ first check the memo</p><p>+ else instead of returning your recursive case, store it in memo then return</p><p>&nbsp;</p><pre><code class=\"language-javascript\">/**\r\n * memoization\r\n * js object, keys will be arg to fn, value will be return value\r\n * @param {*} n \r\n * @param {*} memo ?\r\n */\r\nconst fib = (n, memo={}) =&gt; {\r\n    // first check memo\r\n    if (n in memo) return memo[n];    \r\n    if (n&lt;=2) return 1;\r\n    // store in memo\r\n    memo[n] = fib(n-1, memo) + fib(n-2, memo);\r\n    return memo[n];\r\n};\r\n\r\nconsole.log(fib(50));</code></pre><p>&nbsp;</p>",
        "start": 1558,
        "position": 17,
        "video": {
            "id": "video-8c1a3202-d95a-4181-9f27-249630ec0a04",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 1557.9886851296997,
            "total": 18602
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-f93c5096-fe36-4529-9c22-56ed05dfbe51",
        "description": "<p>Understand the optimized code using Memoization (using Tree diagram)</p>",
        "start": 1904,
        "position": 18,
        "video": {
            "id": "video-0007f953-2a30-4986-b9b9-245f34369f96",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 1904.3894609141694,
            "total": 18602
        },
        "pin": "green"
    }, {
        "id": "bookmark-0c78e606-7f98-4372-9d65-397e5a58a97b",
        "pin": "green",
        "description": "<p><strong>Space Time Complexity using Memoization</strong></p><p>&nbsp;</p><p>+ We definitely cut down the whole runtime of the Fibonacci series</p><p>+ New Time Complexity: <strong>O(n)</strong> = where n is the height of the tree</p><p>+ New Space Complexity: <strong>O(n)</strong> = where n is the number of stacks called</p><p>&nbsp;</p><p><i>Using Memoization, we brought down the Time complexity from being exponential to a linear time complexity - Pretty powerful</i></p>",
        "start": 2142,
        "position": 19,
        "video": {
            "id": "video-25204ecf-fb2b-4ef0-ab99-6ea6bd4df84a",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 2141.7331049980926,
            "total": 18601.941
        }
    }, {
        "id": "bookmark-999fca94-7bb9-4a4d-8094-bb10da92278c",
        "description": "<p><strong>📜 Challenge #2: Grid Traveler</strong></p><p><br><strong>Problem Statement</strong></p><p><i>\"Say that you're a traveler in a 2D grid. You begin in the top-left corner &amp; your goal is to travel to the bottom-right corner. You may only move down or right\"</i></p><p><i>\"In how many ways can you travel to the goal on a grid with dimensions mxn\"</i></p><p>&nbsp;</p><pre><code class=\"language-plaintext\">gridTraveler(m,n); // where m is the number of rows, n - number of columns</code></pre><p>&nbsp;</p><p><strong>Step 1: Ask clarifying question</strong></p><p>+ Is the grid a square grid (MxM) or a rectangular grid (MxN) - <i>Can be a rectangle also, not necessarily a square</i></p><p>+ Explain with a diagram</p><p>+ Ask - what happens if our grid is zero ?</p>",
        "start": 2321,
        "position": 20,
        "video": {
            "id": "video-66afde5e-8d4e-4ee8-9766-b1a005eefba3",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 2320.855694830246,
            "total": 18601.941
        },
        "pin": "yellow"
    }, {
        "id": "bookmark-df3f6c39-abc0-455c-ae1e-8bd6b7986248",
        "description": "<p>Breaking down the problem into sub-problems</p><p>&nbsp;</p><p>+ Try to frame the problem using relatively small units ?</p><p>+ What does it mean to have a 0x0 grid ?</p><p>&nbsp;</p><pre><code class=\"language-javascript\">gridTraveler (1,1) -&gt; 0\ngridTraveler (1,0) -&gt; 0\ngridTraveler (0,1) -&gt; 0\ngridTraveler (0,0) -&gt; 0\ngridTraveler (M,0) -&gt; 0\ngridTraveler (0,N) -&gt; 0</code></pre><p>&nbsp;</p><p>+ We have now some edge cases we can code</p>",
        "start": 2423,
        "position": 21,
        "video": {
            "id": "video-99bc1a94-2baa-435c-8ba8-856f251b99ad",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 2422.977149032425,
            "total": 18601.941
        }
    }, {
        "id": "bookmark-7614af0b-375d-496e-a892-9216855a1ad4",
        "description": "<p><strong>Let's consider a grid - 3x3</strong></p><p>&nbsp;</p><p>+ Consider how we can decrease the problem size</p><p>+ We know we always travel from <strong>top-left</strong> to <strong>bottom-right</strong></p><p>+ We know we have overlapping sub-problem</p><p>+ Using a tree makes sense since we only need to consider 2 directions -&gt; <strong>down</strong> and <strong>right</strong></p><p>+ Left node of the tree (Down) -&gt; means reduce the row M by 1 (M-1)</p><p>+ Right node of tree (Right) -&gt; means reduce the column N by 1 (N-1)</p><p>&nbsp;</p><pre><code class=\"language-javascript\">gridTraveler (3,3) -&gt; gridTraveler(2,3) -&gt; gridTraveler(1,3) -&gt; gridTraveler(1,2) -&gt; gridTraveler(1,1) which is our base case</code></pre>",
        "start": 2524,
        "position": 22,
        "video": {
            "id": "video-e51a4e29-670c-46a3-b6bf-4bb9954a3615",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 2523.7752299923704,
            "total": 18601.941
        },
        "pin": "red"
    }, {
        "id": "bookmark-e3e57698-9376-4f84-b411-0fb224cbe211",
        "pin": "cyan",
        "description": "<p><strong>Classic implementation of Grid Traveler</strong> (w/o Memoization)</p><p>&nbsp;</p><p><strong>Brute Force approach</strong></p><p>&nbsp;</p><p>+ We'll implement the 2 base case scenarios</p><p>+ If both row and column are 1 then return 1</p><p>+ If either row or column are 0 then return 0 since there is no grid!</p><p>+ For all other scenario, we will follow the Tree (left and right) approach, so same as fibonacci</p><p>&nbsp;</p><pre><code class=\"language-javascript\">// basic implementation - w/o memo\nconst gridTraveler = (m,n) =&gt; {\n   // base case #1 - 1x1 grid\n   if (m===1 &amp;amp;&amp;amp; n===1) return 1;\n   // base case #2 - if either row or column is 0, answer is 0\n   if (m===0 || n===0) return 0;\n   // down and right (left and right nodes) of binary tree\n   // so same formula as fibonacci\n   return gridTraveler(m,n-1) + gridTraveler(m-1,n);\n};</code></pre>",
        "start": 2946,
        "position": 23,
        "video": {
            "id": "video-220b2a53-2f41-432f-a13d-8f301d122146",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 2945.7773759732972,
            "total": 18602
        }
    }, {
        "id": "bookmark-5fae6ff6-8e82-458e-bad8-9f4adde33fb8",
        "description": "<p><strong>Drawing board - analysis of brute force solution</strong></p><p>&nbsp;</p><p><strong>Space Time complexity</strong></p><p>+ Time = <strong>O(Math.pow(2, (n+m))</strong> -&gt; where m is rows and n is columns, since its a rectangular grid, worst case time complexity will be O(Math.pow(2,n)) -&gt; Exponential</p><p>+ Space = <strong>O(n+m)</strong> -&gt; for same reasons</p><p>&nbsp;</p>",
        "start": 3054,
        "position": 24,
        "video": {
            "id": "video-f2abc5fc-7516-4b07-a12b-10919c5cf6b9",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 3054.450121994278,
            "total": 18602
        },
        "pin": "red"
    }, {
        "id": "bookmark-8b97fea3-bcfc-4b70-aba4-f0359d7968bf",
        "pin": "cyan",
        "description": "<p><strong>Grid Traveler Problem with Memoization</strong></p><p>&nbsp;</p><p><i>Same Grid Traveler problem with Memoization</i><br>&nbsp;</p><pre><code class=\"language-javascript\">\n/**\n * function to find number of ways to travel from top left\n * to bottom right in a MxN grid\n * constraints - can only travel down / right\n * @param {number} m \n * @param {number} n \n * @param {Object || null} memo \n */\nconst gridTraveler = (m,n,memo={}) =&gt; {\n    // prep a unique key\n    const rowCol = `${m}:${n}`;\n    if (rowCol in memo) return memo[rowCol];\n    if (m === 1 &amp;amp;&amp;amp; n === 1) return 1;\n    if (m === 0 || n === 0) return 0;\n    memo[rowCol] = gridTraveler(m-1, n, memo) + gridTraveler(m,n-1, memo);\n    return memo[rowCol];\n};\n\n[m,n] = [18,18];\nconsole.log(`Number of ways in a ${m} x ${n} is: `, gridTraveler(m,n));\n\n\n// Space Time Complexity\n// Time = O(N*M) -&gt; since we're always memoizing one side of the binary tree\n// Space = O(N+M) -&gt; We are calling the stacks recursively and going through one height at a time</code></pre>",
        "start": 3380,
        "position": 25,
        "video": {
            "id": "video-d9dd924a-2880-44cc-8cf4-e5f9045f8bc2",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 3380.0638141956456,
            "total": 18602
        }
    }, {
        "id": "bookmark-c26f284b-7b76-443a-ad17-b0d6e3b1bbd2",
        "description": "<p><strong>Drawing board to analyze our memoized code</strong></p><p>&nbsp;</p><p><strong>Space Time Complexity</strong></p><p>+ Time Complexity -&gt; O(n*m) =&gt; where n is the number of rows and m, the number of columns</p><p>+ Space Complexity -&gt; O(n+m) =&gt; where n is the number of rows and m, the number of columns</p>",
        "start": 3704,
        "position": 26,
        "video": {
            "id": "video-d3450886-af5f-4ae7-916e-4aa3b9d19b27",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 3704.3700115020574,
            "total": 18602
        }
    }, {
        "id": "bookmark-cdbf76b7-1495-4ecc-a3dd-77a7dd584f0b",
        "description": "<p><strong>✨Alvin's Memoization Recipe✨</strong></p><p><br>Here are few tips on attaining a Memoized code solution -</p><p>&nbsp;</p><p>+ Make your brute force approach work</p><p>+ Make It efficient later</p><p>+ Use Javascript Object as memo</p><p>+ Make checking &amp; retrieving the first line of code in your recursive function</p><p>+ Then comes the base case(s)</p><p>+ Your recursive case must be assigned to the memo</p><p>+ If your solution involves a tree, try to visualise the \"leaf\" ☘️ as the base case of your recursion</p><p>+ Test your brute force solution</p><p>&nbsp;</p>",
        "start": 3895,
        "position": 27,
        "video": {
            "id": "video-0ea9fc01-de81-46b0-a64f-30a7b962c6e0",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 3894.542241437539,
            "total": 18602
        }
    }, {
        "id": "bookmark-d1bff535-fa3b-4577-aee6-1a7b945ea5fb",
        "description": "<p><strong>📜 Challenge #3 - CanSum challenge</strong></p><p>&nbsp;</p><p>Write a function canSum(targetSum, numbers) that takes in a targets and an array of numbers as arguments.</p><p>&nbsp;</p><p>The function should return a boolean true or false indicating whether or not it is possible to generate the targetSum using numbers from the array.</p><p>&nbsp;</p><p>Constraints<br>+ You can use the elements of the array as many times as you want</p><p>+ All elements are non-negative numbers</p><p>&nbsp;</p>",
        "start": 4199,
        "position": 28,
        "video": {
            "id": "video-2d9d0965-e56d-40fb-953b-525494b7f4b8",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 4199.019655075076,
            "total": 18601.941
        },
        "pin": "yellow"
    }, {
        "id": "bookmark-d88443f4-8051-441b-9d6d-20e52ca7e61a",
        "description": "<p>Visualize the problem using a Tree diagram</p>",
        "start": 4295,
        "position": 29,
        "video": {
            "id": "video-646fd4fd-358a-4fec-862c-9c410ae4d786",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 4295.286632984529,
            "total": 18601.941
        }
    }, {
        "id": "bookmark-a912b03d-d685-477f-b9f0-0fd8eb4ec4ce",
        "description": "<p>Visualize Another example using a Tree</p>",
        "start": 4542,
        "position": 30,
        "video": {
            "id": "video-79858bcc-e9a4-499e-92c7-5aba0eaec3d1",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 4541.775068999742,
            "total": 18601.941
        }
    }, {
        "id": "bookmark-36ba3d2d-7582-4786-ad4f-012022313640",
        "pin": "cyan",
        "description": "<p><strong>CanSum function implementation</strong> (in Javascript)</p><p>&nbsp;</p><pre><code class=\"language-javascript\">/**\n* \"canSum\" function\n* function that takes in a targets and \n* an array of numbers as arguments.\n*/\nconst canSum = (targetSum, numbers) =&gt; {\n   // base case\n   if (targetSum === 0) return true;\n   for (num of numbers) {\n     const remainder = targetSum - num;\n     // call recursively\n     if(canSum(remainder, numbers) === true){\n       return true;\n     } \n   }\n   // we have exhausted our search\n   return false;\n};\n\nconsole.log(canSum(7,[2,3]);\nconsole.log(canSum(7,[5,3,4,7]);\nconsole.log(canSum(7,[2,4]);\nconsole.log(canSum(8,[2,3,5]);</code></pre><p>&nbsp;</p><p><strong>Space Time Complexity</strong><br>+ Time Complexity: O(Math.pow(n,m)) - It's not a binary tree, each child goes through the loop over and over again. So some nodes have 2 or 3 child nodes</p><p>+ Space Complexity: O(m) - Recursive call stack.</p>",
        "start": 4598,
        "position": 31,
        "video": {
            "id": "video-3ec3430f-1fb0-42aa-9cb5-4bc68016a074",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 4597.845938048393,
            "total": 18601.941
        }
    }, {
        "id": "bookmark-1cc3f732-1a2a-4b0e-aaec-3c98df94b4e7",
        "description": "<p><strong>Space Time Complexity of the memoized solution</strong></p><p>Time Complexity: <strong>O(m*n) time</strong> - Because of the memo object. The values. will be upto the time of m. We don't have to re-approach the child nodes. But we have to loop through the arrays.</p><p>Space complexity: <strong>O(m)</strong> -&gt; Because of recursive call stack</p>",
        "start": 5337,
        "position": 32,
        "video": {
            "id": "video-8ace51fd-ce3d-4827-b23f-4bcd7a8bd008",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 5337.102102801007,
            "total": 18601.941
        }
    }, {
        "id": "bookmark-b5bece62-2b2a-45d7-8c47-c6fda48f738d",
        "description": "<p>CanSum function with memoized approach</p><p>&nbsp;</p><p>+ When you have multiple arguments, always try to analyze which argument affects the output more. Use that as key for your memo</p><p>+ Remember - Your <strong>returns</strong> in recursive calls should be assigned to the memo not the recursive function</p><p>&nbsp;</p><pre><code class=\"language-javascript\">/**\n* CanSum function with memoized approach\n* @param {number} targetSum\n* @param {number[]} numbers\n* @param {Object} optional - memo\n* @returns {boolean} true or false\n*/ \nconst canSum = (targetSum, numbers, memo={}) =&gt; {\n   // retrieve from memo\n   if (targetSum in memo) return memo[targetSum];\n   // base case #1\n   if (targetSum === 0) return true;\n   // base case #2\n   if (targetSum &lt; 0) return false;\n   // loop\n   for (let num of numbers) {\n     // subtract from the targetSum\n     const remainder = targetSum - num;\n     // recursive check\n     if (canSum(remainder, numbers, memo) === true) {\n         // store in memo - NOTE: key is still - targetSum\n         memo[targetSum] = true;\n         return true;\n     }\n   }\n   // store in memo\n   memo[targetSum] = false;\n   return false;\n};\n\nconsole.log(canSum(300, [7,14]));</code></pre><p>&nbsp;</p><p>Space Time Complexity</p><p>&nbsp;</p><p>+ Time - <strong>O(n x m) </strong>- With memoized solution we at the least, travel through the child node heights</p><p>+ Space - <strong>O(n)</strong> - Recursive call stack</p><p>&nbsp;</p><p><i>Using Memoization, we've reduced the Time Complexity from Exponential to Linear !!</i></p><p>&nbsp;</p>",
        "start": 5101,
        "position": 33,
        "video": {
            "id": "video-f3f11c4e-34c0-4bd3-87b7-1c669a882de8",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 5100.94902318607,
            "total": 18601.941
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-3e99aa43-7030-4502-b44e-886a904f6ad4",
        "description": "<p>CanSum - Brute force approach versus Memoized approach</p>",
        "start": 5356,
        "position": 34,
        "video": {
            "id": "video-5c640e48-8f24-4191-b0fa-1b61747bd58d",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 5356.482195971614,
            "total": 18601.941
        }
    }, {
        "id": "bookmark-43f2af27-5213-4e23-a8f2-fc7656ab96cf",
        "description": "<p><strong>📜 Challenge #4 - HowSum function</strong></p><p>&nbsp;</p><p><i>Write a function howSum(targetSum, numbers) that takes in a targetSum &amp; an array of numbers as arguments.</i><br>&nbsp;</p><p>+ The function should return an array containing any combination of elements that add upto exactly the targetSum.&nbsp;<br>+ if there is no combination that adds to the targetSum, then return null.</p><p>&nbsp;</p><p>👉🏻 <i><strong>The Tree diagram is really beautifully explained here</strong></i></p>",
        "start": 5373,
        "position": 35,
        "video": {
            "id": "video-63bdbacc-5e9f-4236-a1e7-52b6564b6189",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 5372.707110791075,
            "total": 18601.941
        },
        "pin": "yellow"
    }, {
        "id": "bookmark-ac2bedc9-5677-4d5a-9fdc-90892f7fd9c3",
        "description": "<p>HowSum function implementation (Brute force approach)</p><p>&nbsp;</p><p>+ As in canSum, in this approach as well, we have 2 base case scenarios, if targetSum equals OR less than 0</p><p>+ if targetSum equals 0, return an empty [] (to start the bubble up process)</p><p>+ if targetSum &lt; 0, return null (terminate)</p><p>&nbsp;</p><pre><code class=\"language-javascript\">const howSum = (targetSum, numbers) =&gt; {\n  // base case #1\n  if (targetSum === 0) return [];\n  // base case #2\n  if (targetSum &lt; 0) return null;\n  for (num of numbers) {\n     const remainder = targetSum - num;\n     // new line, unlike canSum\n     const remainderResult = howSum(remainder, numbers);\n     if (remainderResult) {\n        return [...remainderResult, num];\n     }\n  }\n  \n  // completed loop check\n  return null;\n};\n\n// testing\nconsole.log(howSum(7,[2,3])); // [3,2,2]\nconsole.log(howSum(7,[5,3,4,7])); // null\nconosle.log(howSum(8,[2,3,5])); // [2,2,2,2]\nconsole.log(howSum(300,[7,14])); // null </code></pre><p>&nbsp;</p><p>Space Time Complexity</p><p>&nbsp;</p><p>+ Time Complexity <strong>O(Math.pow(n, m))</strong> -&gt; <strong>O(n^m)</strong> + O(m) ~ <strong>O(n^m)</strong> where is n is the number of child nodes each node, m is the height of the tree</p><p>+ Space Complexity: <strong>O(m)</strong> -&gt; Recursive call stack down the tree</p>",
        "start": 5831,
        "position": 36,
        "video": {
            "id": "video-d1650256-9343-4f12-a1f4-8d9bacf3080a",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 5831.44232921469,
            "total": 18601.941
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-9b43ce1f-0024-47e5-9b69-0ec119088f31",
        "pin": "cyan",
        "description": "<p>HowSum function with Memoization</p><p>&nbsp;</p><pre><code class=\"language-javascript\">const howSum = (targetSum, numbers, memo={}) =&gt; {\n  // retrieval - same as canSum\n  if (targetSum in memo) return memo[targetSum];\n  // base case #1\n  if (targetSum === 0) return [];\n  // base case #2\n  if (targetSum &lt; 0) return null;\n  for (num of numbers) {\n     const remainder = targetSum - num;\n     // new line, unlike canSum\n     const remainderResult = howSum(remainder, numbers);\n     if (remainderResult) {\n        // store in memo...\n        return [...remainderResult, num];\n     }\n  }\n  \n  // completed loop check\n  return null;\n};\n\n// testing\nconsole.log(howSum(7,[2,3])); // [3,2,2]\nconsole.log(howSum(7,[5,3,4,7])); // null\nconosle.log(howSum(8,[2,3,5])); // [2,2,2,2]\nconsole.log(howSum(300,[7,14])); // null </code></pre>",
        "start": 6408,
        "position": 37,
        "video": {
            "id": "video-eed60cd2-8826-456d-a61f-e4b10fa41102",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 6407.719839411832,
            "total": 18601.941
        }
    }, {
        "id": "bookmark-c2d1d55c-aafe-4ffe-b390-99dd1d66795b",
        "description": "<p>50% Completed !!</p>",
        "start": 9005,
        "position": 38,
        "video": {
            "id": "video-bac8d8d2-e63d-45c5-ba65-9324466e6885",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 9004.920422982834,
            "total": 18601.941
        },
        "pin": "purple"
    }]
}