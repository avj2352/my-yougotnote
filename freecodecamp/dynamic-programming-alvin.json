{
    "id": "playlist-5bbf0d1e-d758-4db7-8668-ede26c5df8de",
    "title": "Dynamic Programming Basics - Collection",
    "createdBy": "",
    "bookmarks": [{
        "id": "bookmark-21339cfd-0cad-4a31-bdbd-168b750cd78c",
        "description": "<p>Hey Programmers, I am Alvin</p><p>&nbsp;</p><p>Welcome to - <strong>Dynamic Programming Course</strong></p>",
        "start": 6,
        "position": 1,
        "video": {
            "id": "video-355f99c0-4a3f-4697-9f68-74bd889ad203",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 5.821207,
            "total": 18602
        }
    }, {
        "id": "bookmark-5329c162-967b-4460-9dea-5989aafc9e45",
        "description": "<p><i>Problems we're going to solve in this course -</i><br>&nbsp;</p><p>1. Calculate the 40th number of fibonacci sequence</p><p>2. Count the number of different ways to move through a 6x9 grid</p><p>3. Given a set of coins, how can we make 27 cents in the least number of coins</p><p>4. Given a set of substrings, what're the possible ways to construct the string <strong>\"potentpot\"</strong></p>",
        "start": 49,
        "position": 2,
        "video": {
            "id": "video-e8affe11-dd9b-4db6-a7b2-3a9773d5e14a",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 48.78339704005432,
            "total": 18602
        },
        "pin": "green"
    }, {
        "id": "bookmark-87c3f6d2-33b1-440d-8879-76de4363d436",
        "description": "<p>Visualize algorithms</p>",
        "start": 102,
        "position": 3,
        "video": {
            "id": "video-3ebdb82d-8a2a-43cc-9d28-07bb6ebb7340",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 101.85076303814698,
            "total": 18602
        }
    }, {
        "id": "bookmark-cee30b07-8d9b-49ff-9f41-93268e1f7ce2",
        "description": "<p><i>Dynamic Programming concepts - <strong>solving Overlapping Sub-problems</strong> &nbsp;techniques covered -</i><br><br>Part 1: Memoization<br>Part 2: Tabulation<br><br><i>Pre-requisite required</i><br><br>1. Basics of Recursion<br>2. Basics of Complexity Analysis</p>",
        "start": 166,
        "position": 4,
        "video": {
            "id": "video-b8a8124f-766a-4646-92fc-2543a2793d9e",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 166.10665610681153,
            "total": 18602
        },
        "pin": "green"
    }, {
        "id": "bookmark-d7dbb6d0-c065-41c9-8995-0cf845315ed2",
        "description": "<p>ðŸ“œ <strong>Challenge #1 - program a fibonacci using memoization</strong><br><br><i>Write a function fib(n) that takes in a number as an argument. The function should return the nth number of the Fibonacci sequence</i><br><br>+ The 1st &amp; 2nd number of the sequence is 1.<br>+ To generate the next number of the sequence, we sum the previous two<br>&nbsp;</p>",
        "start": 206,
        "position": 5,
        "video": {
            "id": "video-3ac0215e-3858-4175-9f09-dcbeb40b6c77",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 205.677969,
            "total": 18602
        },
        "pin": "yellow"
    }, {
        "id": "bookmark-782c2eb7-86c1-4301-977c-5240cd562485",
        "description": "<p>Classic implementation</p><pre><code class=\"language-javascript\">// Classic implementation (w/o memoization)\nconst fib = (n) =&gt; {\n // base-case\n if (n&lt;=2) return 1;\n // recursive case\n return fib(n-1) + fib(n-2);\n};\n\nconsole.log(fib(6)); // 8\nconsole.log(fib(7)); // 13\nconsole.log(fib(8)); // 21\nconsole.log(fib(50)); // takes a looong time</code></pre><p>&nbsp;</p><p><strong>Review: </strong>Problem with this approach - We are re-visiting already visited / computed numbers</p>",
        "start": 275,
        "position": 6,
        "video": {
            "id": "video-a5c31f2e-fd3e-4158-9854-d5d8974441eb",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 275.45966992370603,
            "total": 18602
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-218122a5-67ef-41a4-97a4-d808348f05a3",
        "description": "<p>Students need to work on drawing things....</p>",
        "start": 406,
        "position": 7,
        "video": {
            "id": "video-e55ae7e7-7965-4344-a3a1-a0362d7a9c57",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 405.7348070190735,
            "total": 18602
        }
    }, {
        "id": "bookmark-c1dd9097-4480-44af-a728-b0f7b8c509cc",
        "description": "<p>Drawing a tree to explain optimization approach</p>",
        "start": 457,
        "position": 8,
        "video": {
            "id": "video-86e46e83-fee0-46d4-a26d-bb7170662be8",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 456.75220912016295,
            "total": 18602
        },
        "pin": "red"
    }, {
        "id": "bookmark-6258308c-10da-417f-bf81-50f641666264",
        "description": "<p>The Above solution approach is explained...<br><br>+ For all of these base cases, I know they return 1 to their parent<br>+ and all the parent nodes add up these base cases</p>",
        "start": 615,
        "position": 9,
        "video": {
            "id": "video-138b84b9-e006-40bc-9126-ccc0eb130930",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 615.4869470267029,
            "total": 18602
        }
    }, {
        "id": "bookmark-32c3daf8-3ace-49b9-a815-2137210e5aa3",
        "description": "<p>Time Complexity<br><br>+ Off-hand people mention that a Fibonacci recursive implementation Big-O is - <strong>2^n</strong><br>+ This drawing is asymmetric.<br>+ Students have a real hard time convincing themselves on this <strong>2^n</strong></p>",
        "start": 646,
        "position": 10,
        "video": {
            "id": "video-0beb427f-cc06-425c-befe-99b4fdb20f66",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 646.2404470267029,
            "total": 18601.941
        }
    }, {
        "id": "bookmark-209abced-658e-439d-8b59-db51cbe7cede",
        "description": "<p><strong>Basic refresher of Space Time Complexity for Recursion -</strong><br><br><strong>Example #1</strong><br>&nbsp;</p><pre><code class=\"language-javascript\">const foo = (n) =&gt; {\n if(n&lt;=1) return;\n foo(n-1);\n};</code></pre><p>&nbsp;</p><p>+ Time Complexity - <strong>O(n) - </strong>Takes n time to go through recursion</p><p>+ Space Complexity - <strong>O(n) </strong>- N times the function is called - Stacks function therefore <strong>O(n)</strong></p><p>&nbsp;</p><p><strong>Example #2</strong></p><p>&nbsp;</p><pre><code class=\"language-javascript\">const bar = (n) =&gt; {\n if(n&lt;=1) return;\n foo(n-2);\n};</code></pre><p>&nbsp;</p><p>+ Time Complexity - O(n/2) ~ O(n)<br>+ Space Complexity - O(n/2) ~ O(n)</p>",
        "start": 685,
        "position": 11,
        "video": {
            "id": "video-1146e212-beaf-4e4c-83e3-ff6611fb5f69",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 684.8481930648499,
            "total": 18601.941
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-d86014c4-8f9a-454d-9303-645488c602a9",
        "description": "<p><strong>Example #3</strong></p><p>&nbsp;</p><pre><code class=\"language-javascript\">// produces a symmetric tree\nconst dib = (n) =&gt; {\n if (n&lt;=1) return;\n dib(n-1); // left child\n dib(n-1); // right child\n};</code></pre><p><br>+ Time Complexity - <strong>O(2^n)</strong><br>&nbsp; &nbsp; &nbsp;- First consider one of the paths, that will also be the height of the tree<br>&nbsp; &nbsp; &nbsp;- Height is also called - Levels<br>&nbsp; &nbsp; &nbsp;- The number of nodes doubles every level<br>+ Space Complexity - <strong>O(n)</strong><br>&nbsp; &nbsp; - Students always assume Space = Time when it comes to recursive function<br>&nbsp; &nbsp; - At any given time, the number of stacks is same as that of the height of the tree</p>",
        "start": 853,
        "position": 12,
        "video": {
            "id": "video-8505f7e9-b4e4-4278-805a-576019c3635e",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 853.1214597959137,
            "total": 18601.941
        },
        "pin": "red"
    }, {
        "id": "bookmark-ca47d8b2-00d3-45d9-bd0f-a6c8de9949db",
        "description": "<p><strong>Example #4</strong></p><p>&nbsp;</p><pre><code class=\"language-javascript\">// produces a symmetric tree\nconst lib = (n) =&gt; {\n if (n&lt;=1) return;\n dib(n-2); // left child\n dib(n-2); // right child\n};</code></pre><p><br>+ Time Complexity - <strong>O(2^n/2) ~ O(2^n)</strong><br>&nbsp; &nbsp; &nbsp;- First consider one of the paths, that will also be the height of the tree<br>&nbsp; &nbsp; &nbsp;- Height is also called - Levels<br>&nbsp; &nbsp; &nbsp;- The number of nodes SKIPS two steps every level so the height is halved.<br>+ Space Complexity - <strong>O(n/2) ~ O(n)</strong><br>&nbsp; &nbsp; - Students always assume Space = Time when it comes to recursive function<br>&nbsp; &nbsp; - At any given time, the number of stacks is half as that of the height of the tree</p>",
        "start": 1200,
        "position": 13,
        "video": {
            "id": "video-f5286d4f-8d77-4bc3-8d87-0107539602ef",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 1199.664206885559,
            "total": 18602
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-a425bb55-5a97-447c-b038-e70239523f8f",
        "description": "<p>Where does our Fibonacci fit in these 4 examples ?</p><p>&nbsp;</p><pre><code class=\"language-plaintext\">Time - O(dib) &lt;= O(fib) &lt;= O(lib)</code></pre>",
        "start": 1281,
        "position": 14,
        "video": {
            "id": "video-786219cd-2368-48a2-8b94-13c611d4d912",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 1281.149031049591,
            "total": 18602
        }
    }, {
        "id": "bookmark-139055ac-b2f2-469d-aa0e-d04ece62e6df",
        "description": "<p>O(2^n) is not a good Time Complexity (explained)...<br><br>+ Consider fib(50) ~ 2^50<br>+ if we just bring up the calculator &amp; do a 2 raised to 50 = <strong>1,1,25,899,906,842,624</strong> steps !!&nbsp;<br>+ One quadrillion steps</p>",
        "start": 1356,
        "position": 15,
        "video": {
            "id": "video-4b57cc6a-2bf1-424b-827b-6c30891bae9a",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 1356.2389128550415,
            "total": 18602
        },
        "pin": "red"
    }, {
        "id": "bookmark-8c14283f-cfd8-4322-8bce-44db1958babd",
        "description": "<p><strong>Overlapping Sub-problems explained...</strong></p><p>&nbsp;</p><p>+ A lot of duplicates in my subtree</p><p>+ I know my previous number fibonacci doesn't change</p><p>&nbsp;</p><p><i>Solving these kind of Overlapping Sub-problems is the core of <strong>\"Dynamic Programming\"</strong></i></p><p>&nbsp;</p><p>+ Any instance where we have a larger problem, We decompose it into smaller sub-problems</p><p>+ We also have overlapping sub-problems</p><p>+ Identify which of the sub-problem is &nbsp;a duplicate</p>",
        "start": 1441,
        "position": 16,
        "video": {
            "id": "video-069e5147-48c4-4a8a-8c3c-09f3c0cce75b",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 1440.895907956131,
            "total": 18602
        },
        "pin": "red"
    }, {
        "id": "bookmark-78ea8ed9-3cd0-4fef-95d6-b701b38e3f99",
        "description": "<p><strong>Solution to optimize Class Fibonacci implementation (Javascript)</strong></p><p>&nbsp;</p><p>+ Create a memo (fast access - HashMap / Map / Object in Javascript)</p><p>+ keys to the memo will be the argument to the function</p><p>+ first check the memo</p><p>+ else instead of returning your recursive case, store it in memo then return</p><p>&nbsp;</p><pre><code class=\"language-javascript\">/**\r\n * memoization\r\n * js object, keys will be arg to fn, value will be return value\r\n * @param {*} n \r\n * @param {*} memo ?\r\n */\r\nconst fib = (n, memo={}) =&gt; {\r\n    // first check memo\r\n    if (n in memo) return memo[n];    \r\n    if (n&lt;=2) return 1;\r\n    // store in memo\r\n    memo[n] = fib(n-1, memo) + fib(n-2, memo);\r\n    return memo[n];\r\n};\r\n\r\nconsole.log(fib(50));</code></pre><p>&nbsp;</p>",
        "start": 1558,
        "position": 17,
        "video": {
            "id": "video-8c1a3202-d95a-4181-9f27-249630ec0a04",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 1557.9886851296997,
            "total": 18602
        },
        "pin": "cyan"
    }, {
        "id": "bookmark-f93c5096-fe36-4529-9c22-56ed05dfbe51",
        "description": "<p>Understand the optimized code using Memoization (using Tree diagram)</p>",
        "start": 1904,
        "position": 18,
        "video": {
            "id": "video-0007f953-2a30-4986-b9b9-245f34369f96",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 1904.3894609141694,
            "total": 18602
        },
        "pin": "green"
    }, {
        "id": "bookmark-0c78e606-7f98-4372-9d65-397e5a58a97b",
        "pin": "green",
        "description": "<p><strong>Space Time Complexity using Memoization</strong></p><p>&nbsp;</p><p>+ We definitely cut down the whole runtime of the Fibonacci series</p><p>+ New Time Complexity: <strong>O(n)</strong> = where n is the height of the tree</p><p>+ New Space Complexity: <strong>O(n)</strong> = where n is the number of stacks called</p><p>&nbsp;</p><p><i>Using Memoization, we brought down the Time complexity from being exponential to a linear time complexity - Pretty powerful</i></p>",
        "start": 2142,
        "position": 19,
        "video": {
            "id": "video-25204ecf-fb2b-4ef0-ab99-6ea6bd4df84a",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 2141.7331049980926,
            "total": 18601.941
        }
    }, {
        "id": "bookmark-999fca94-7bb9-4a4d-8094-bb10da92278c",
        "description": "<p><strong>ðŸ“œ Challenge #2: Grid Traveler</strong></p><p><br><strong>Problem Statement</strong></p><p><i>\"Say that you're a traveler in a 2D grid. You begin in the top-left corner &amp; your goal is to travel to the bottom-right corner. You may only move down or right\"</i></p><p><i>\"In how many ways can you travel to the goal on a grid with dimensions mxn\"</i></p><p>&nbsp;</p><pre><code class=\"language-plaintext\">gridTraveler(m,n); // where m is the number of rows, n - number of columns</code></pre><p>&nbsp;</p><p><strong>Step 1: Ask clarifying question</strong></p><p>+ Is the grid a square grid (MxM) or a rectangular grid (MxN) - <i>Can be a rectangle also, not necessarily a square</i></p><p>+ Explain with a diagram</p><p>+ Ask - what happens if our grid is zero ?</p>",
        "start": 2321,
        "position": 20,
        "video": {
            "id": "video-66afde5e-8d4e-4ee8-9766-b1a005eefba3",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 2320.855694830246,
            "total": 18601.941
        },
        "pin": "yellow"
    }, {
        "id": "bookmark-df3f6c39-abc0-455c-ae1e-8bd6b7986248",
        "description": "<p>Breaking down the problem into sub-problems</p><p>&nbsp;</p><p>+ Try to frame the problem using relatively small units ?</p><p>+ What does it mean to have a 0x0 grid ?</p><p>&nbsp;</p><pre><code class=\"language-javascript\">gridTraveler (1,1) -&gt; 0\ngridTraveler (1,0) -&gt; 0\ngridTraveler (0,1) -&gt; 0\ngridTraveler (0,0) -&gt; 0\ngridTraveler (M,0) -&gt; 0\ngridTraveler (0,N) -&gt; 0</code></pre><p>&nbsp;</p><p>+ We have now some edge cases we can code</p>",
        "start": 2423,
        "position": 21,
        "video": {
            "id": "video-99bc1a94-2baa-435c-8ba8-856f251b99ad",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 2422.977149032425,
            "total": 18601.941
        }
    }, {
        "id": "bookmark-7614af0b-375d-496e-a892-9216855a1ad4",
        "description": "<p><strong>Let's consider a grid - 3x3</strong></p><p>&nbsp;</p><p>+ Consider how we can decrease the problem size</p><p>+ We know we always travel from <strong>top-left</strong> to <strong>bottom-right</strong></p><p>+ We know we have overlapping sub-problem</p><p>+ Using a tree makes sense since we only need to consider 2 directions -&gt; <strong>down</strong> and <strong>right</strong></p><p>+ Left node of the tree (Down) -&gt; means reduce the row M by 1 (M-1)</p><p>+ Right node of tree (Right) -&gt; means reduce the column N by 1 (N-1)</p><p>&nbsp;</p><pre><code class=\"language-javascript\">gridTraveler (3,3) -&gt; gridTraveler(2,3) -&gt; gridTraveler(1,3) -&gt; gridTraveler(1,2) -&gt; gridTraveler(1,1) which is our base case</code></pre>",
        "start": 2524,
        "position": 22,
        "video": {
            "id": "video-e51a4e29-670c-46a3-b6bf-4bb9954a3615",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 2523.7752299923704,
            "total": 18601.941
        },
        "pin": "red"
    }, {
        "id": "bookmark-e3e57698-9376-4f84-b411-0fb224cbe211",
        "pin": "cyan",
        "description": "<p><strong>Classic implementation of Grid Traveler</strong> (w/o Memoization)</p><p>&nbsp;</p><p><strong>Brute Force approach</strong></p><p>&nbsp;</p><p>+ We'll implement the 2 base case scenarios</p><p>+ If both row and column are 1 then return 1</p><p>+ If either row or column are 0 then return 0 since there is no grid!</p><p>+ For all other scenario, we will follow the Tree (left and right) approach, so same as fibonacci</p><p>&nbsp;</p><pre><code class=\"language-javascript\">// basic implementation - w/o memo\nconst gridTraveler = (m,n) =&gt; {\n   // base case #1 - 1x1 grid\n   if (m===1 &amp;amp;&amp;amp; n===1) return 1;\n   // base case #2 - if either row or column is 0, answer is 0\n   if (m===0 || n===0) return 0;\n   // down and right (left and right nodes) of binary tree\n   // so same formula as fibonacci\n   return gridTraveler(m,n-1) + gridTraveler(m-1,n);\n};</code></pre>",
        "start": 2946,
        "position": 23,
        "video": {
            "id": "video-220b2a53-2f41-432f-a13d-8f301d122146",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 2945.7773759732972,
            "total": 18602
        }
    }, {
        "id": "bookmark-5fae6ff6-8e82-458e-bad8-9f4adde33fb8",
        "description": "<p><strong>Drawing board - analysis of brute force solution</strong></p><p>&nbsp;</p><p>&nbsp;</p>",
        "start": 3054,
        "position": 24,
        "video": {
            "id": "video-f2abc5fc-7516-4b07-a12b-10919c5cf6b9",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 3054.450121994278,
            "total": 18602
        }
    }, {
        "id": "bookmark-c2d1d55c-aafe-4ffe-b390-99dd1d66795b",
        "description": "<p>50% Completed !!</p>",
        "start": 9005,
        "position": 25,
        "video": {
            "id": "video-bac8d8d2-e63d-45c5-ba65-9324466e6885",
            "url": "https://www.youtube.com/watch?v=oBt53YbR9Kk",
            "seen": 9004.920422982834,
            "total": 18601.941
        },
        "pin": "purple"
    }]
}